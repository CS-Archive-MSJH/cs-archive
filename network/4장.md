# 4 전송 계층

## 4-1 전송 계층 개요 : IP의 한계와 포트

### 네트워크 계층과 응용 계층 사이의 전송 계층
  * IP 한계 보완: 신뢰할 수 있는 통신과 연결형 통신 기능 제공
  * 응용 계층의 프로세스(실행 중인 프로그램) 식별: 포트 번호 활용

### 신뢰할 수 없는 통신과 비연결형 통신 
  - IP의 특징
    * 신뢰할 수 없는 (비신뢰성) 프로토콜(Unreliable Protocol)
    * 비연결형 프로토콜(Connectionless Protocol)
  
  - IP 패킷의 전달 = 신뢰성이 없는 통신 + 비연결형 통신

  - 신뢰할 수 없는 통신
    * 패킷이 수신지까지 제대로 전송되었다는 보장을 하지 않음
    * 통신 과정에서 패킷이 잘못 전송 되어도 이를 확인하지 않고,
      재전송도 하지 않으며, 순서대로 패킷이 도착할 것이라는 보장도 하지 않는다는 의미
    * 최선형 전달(Best Effort Delivery)라고 하며, 최선을 다해보겠지만, 전송 결과애 대해서 어떠한 보장도 하지 않겠다는 뜻.     

  - 비연결형 통신
    * 송수신 호스트 간에 사전 연결 수립 작업을 거치지 않음
    * 그저 수신지를 향해 패킷을 보내기만 할 뿐
    * 전송 계층에는 송수신 호스트 간에 사전 연결 수립 작업을 거침. 이를 TCP라함.

  - IP는 왜 신뢰할 수 없는, 비연결형 통신을 할까?
    - 주된 이유는 성능! 신뢰할 수 없는 통신 = 성능에 악영향
    - 신뢰성 있는 전송이 모든 경우에 필요한 것은 아님

  - TCP 
    * 연결형 통신을 가능하게 함
      - 송수신하는 동안에는 연결을 유지하고, 송수신이 끝나면 연결을 종료
    * 신뢰성 있는 통신을 가능하게 함
      - 재전송을 통한 오류 제어, 흐름 제어, 혼잡 제어 등 다양한 기능들을 제공
      
  - UDP 
    * 신뢰할 수 없는 통신, 비연결형 통신을 가능하게함
    * TCP보다 비교적 빠른 전송이 가능

  <img src="assets/chapter4-1.png" width="800" />

### 응용 계층을 식별하는 전송 계층
  - 포트를 활용한 애플리케이션 식별
    * 포트(Port): 네트워크 상의 애플리케이션 식별 정보
      - 패킷은 실행 중인 특정 애플리케이션 프로세스까지 전달되어야함.

  <img src="assets/chapter4-2.png" width="800" />

  - 포트의 분류
    * 패킷 내 수신지 포트와 송신지 포트를 통해 송수신지 호스트의 애플리케이션을 식별
    * 16비트로 표현 가능: 사용 가능한 포트의 수는 2^16(65536)개
      - 할당 가능한 포트 번호: 0번~65535번

    | 포트 종류    | 포트 번호 범위   |
    |:-------------:|:------------:|
    | 잘 알려진 포트(Well-known Port)| 0~1023     |
    | 등록된 포트(Registered Port)  | 1024~49151 |
    | 동적 포트(Dynamic Port)  | 49152~65535 |

  - 잘 알려진 포트
    * 0번부터 1023번까지의 포트
    * 시스템 포트(System Port)
    * 범용적으로 사용되는 애플리케이션 프로토콜이 일반적으로 사용하는 포트 번호를 의미

    | 잘 알려진 포트 번호    | 설명  |
    |:-------------:|:------------:|
    | 20, 21 | FTP |
    | 22 | SSH |
    | 23 | TELNET |    
    | 53 | DNS |   
    | 68,68 | DHCP |   
    | 80 | HTTP |  
    | 443 | HTTPS |   

  - 등록된 포트
    * 포트 번호 1024번부터 49151번까지
    * 잘 알려진 포트에 비해서 덜 범용적
    * 흔히 사용되는 애플리케이션 프로토콜에 할당하기 위해 사용

    | 등록된 포트 번호    | 설명  |
    |:-------------:|:------------:|
    | 1194 | OpenVPN |
    | 1433 | Microsoft SQL Server 데이터베이스 |
    | 3306 | MySQL 데이터베이스 |    
    | 6379 | Redis |   
    | 8080 | HTTP 대체 |
    | 27017 | Mongo DB |

  - 인터넷 할당 번호 관리 기관(IANA; Internet Assigned Numbers Authority)    
    * 잘 알려진 포트와 등록된 포트
    * 물론 포트 번호는 권고일 뿐 강제 사항은 아님  

  - 동적 포트, 사설 포트(Private Port), 임시 포트(Ephemeral Port)
    * 특별히 관리되지 않는 포트 번호 범위: 자유롭게 사용 가능
    * 서버는 대부분 잘 알려진 포트와 등록된 포트 사용
    * 클라이언트는 대부분 동적 포트 사용
      - ex) 웹 브라우저

  <img src="assets/chapter4-3.png" width="800" />

   - '특정 호스트'에서 실행 중인 '특정 애플리케이션 프로세스' 식별
    * IP 주소: 포트 번호 형식
      ex) 192.168.0.15:8000

### 포트를 활용하는 기술: 포트 기반 NAP
  - NAT
    * NAT 변환 테이블: 변환의 대상이 되는 IP 주소 쌍
    * 사설 IP 주소 하나당 공인 IP 주소 하나가 대응: 많은 사설 IP 주소를 변환하기에는 무리가 있음
    * 공인 IP 주소의 낭비: 사설 IP 주소의 수만큼 공인 IP 주소가 필요

    <p><strong>NAT 변환 테이블</strong></p>

    | 네트워크 외부 | 네트워크 내부 |
    |:-------------:|:------------:|
    | 1.2.3.4 | 192.168.0.5 |
    | 1.2.3.5 | 192.168.0.6 |

  - 포트 기반의 NAT, NAPT
    * NAPT(Network Address Port Translation) 또는 APT (Address Port Translation)
    * NAPT는 NAT 테이블에 변활할 IP 주소 쌍과 더불어 포트 번호도 함께 기록하고, 변환
    * 하나의 공인 IP 주소(1)를 여러 사설 IP 주소(N)로 공유 가능
      - 사설 IP 주소: 공인 IP 주소를 N:1로 변환
      - 공인 IP 주소 수 부족 문제를 개선한 기술

    <p><strong>NAT 변환 테이블</strong></p>

    | 네트워크 외부 | 네트워크 내부 |
    |:-------------:|:------------:|
    | 1.2.3.4:6200 | 192.168.0.5:1025 |
    | 1.2.3.4:6201 | 192.168.0.6:1026 |

### 포트 포워딩(Port Forwarding)
 
- 가령...
  * 네트워크 내부의 여러 호스트가 공인 IP 주소를 공유하는 상황
  * 네트워크 외부에서 내부로 (원격 좁석을 시도하는 등) 통신을 시작하는 상황
  * 외부 호스트 입장에서는 어떤 IP 주소(및 포트)를 수신지 주소로 삼아야할까?

- 포트 포워딩
  * 네트워크 내 특정 호스트에 IP 주소와 포트 번호를 미리 할당하고,
  * 해당 IP 주소:포트 번호로써 해당 호스트에게 패킷을 전달하는 기능

  | 서비스 포트 | 프로토콜 | IP 주소 |  내부 포트 |
  |:-------------:|:------------:|:------------:|:------------:|
  | 1234 | TCP/IP | 192.168.100.100 | 1025 | 
  | 4321 | TCP/IP | 192.168.100.101 | 1026 | 
  
  * 공인 IP 주소:1234로 전송한 패킷은 192.168.100.100:1025로 전달
  * 공인 IP 주소:4321로 전송한 패킷은 192.168.100.101:1026으로 전달

### ICMP(Internet Control Message Protocol)

  - IP의 신뢰할 수 없는 비연결형 통신, 이 전송 특성을 보완하는 ICMP
    * IP 패킷 전송 과정에 대한 피드백 메시지 제공
    * 피드백 메시지?
      - 1. 전송 과정에서 발생한 문제 상황에 대한 오류 보고
      - 2. 네트워크에 대한 진단 정보(네트워크상의 정보 제공)

  - ICMP 메시지 = 타입(Type) + 코드(코드)
    * 타입: ICMP 메시지 유형 번호
    * 코드: 구체적인 메시지 내용 번호

    <p><strong>전송 과정에서 발생한 문제 상황에 대한 오류 보고</strong></p>

    | 타입 이름(타입 번호)                 | 코드 번호 | 코드 설명                                      |
    |:-------------------------------------:|:-----------:|:------------------------------------------------:|
    | 수신지 도달 불가(3) : 특정 패킷이 수신지까지 도달할 수 없음을 나타냄                  | 0         | 네트워크 도달 불가                             |
    | 수신지 도달 불가(3) : 특정 패킷이 수신지까지 도달할 수 없음을 나타냄                         | 1         | 호스트 도달 불가                               |
    | 수신지 도달 불가(3) : 특정 패킷이 수신지까지 도달할 수 없음을 나타냄                    | 2         | 프로토콜 도달 불가; 수신지에서 특정 프로토콜을 사용할 수 없음 |
    | 수신지 도달 불가(3) : 특정 패킷이 수신지까지 도달할 수 없음을 나타냄                         | 3         | 포트 도달 불가                                 |
    | 수신지 도달 불가(3) : 특정 패킷이 수신지까지 도달할 수 없음을 나타냄      | 4         | 단편화가 필요하지만 DF가 1로 설정되어 단편화할 수 없음 |
    | 시간 초과 (11)                      | 0         | TTL 만료        


    <p><strong>네트워크에 대한 진단 정보(네트워크상의 정보 제공)</strong></p>

    | 타입 이름(타입 번호)  | 코드 번호 | 코드 설명                                   |
    |:-----------------------:|:-----------:|:-------------------------------------------:|
    | 에코 요청 (8)         | 0         | 에코 요청                                  |
    | 에코 응답 (0)         | 0         | 에코 요청에 대한 응답                      |
    | 라우터 광고 (9)       | 0         | 라우터 광고; 라우터가 호스트에게 자신을 알림 |

    * Ping, Traceroute 명령어는 ICMP 메시지를 기반으로 동작
    * ICMP는 IP의 보조일 뿐: 신뢰성의 완전 보장 X
    

## 4-2 TCP와 UDP

### 전송 계층의 가장 중요한 프로토콜, TCP와 UDP

  - TCP(Transmission Control Protocol)
    * 신뢰할 수 있는 통신을 위한 연결형 프로토콜

  - UDP(User Datagram Protocol)
    * TCP보다 신뢰성은 떨어지지만 비교적 빠른 통신이 가능한 비연결형 프로토콜

### TCP 통신 단계

  - TCP는 통신(데이터 송수신)하기 전에 연결을 수립하고 통신이 끝나면 연결을 종료
  - 데이터 송수신할 때 신뢰성 있는 전송을 위한 여러가지 기능 제공.

  <div style="display: flex; justify-content: center; align-items: center; font-family: Arial, sans-serif; margin-bottom: 20px;">
      <!-- 연결 수립 -->
      <div style="padding: 20px; border: 2px solid black; border-radius: 20px; text-align: center; margin-right: 10px;">
          <strong>① 연결 수립</strong>
      </div>
      <!-- 화살표 -->
      <div style="margin-right: 10px;">⟶</div>
      <!-- 데이터 송수신 -->
      <div style="padding: 20px; border: 2px solid black; border-radius: 20px; text-align: center; margin-right: 10px;">
          <strong>② 데이터 송수신</strong><br>
          <small>재전송을 통한 오류 제어,<br>흐름 제어, 혼잡 제어</small>
      </div>
      <!-- 화살표 -->
      <div style="margin-right: 10px;">⟶</div>
      <!-- 연결 종료 -->
      <div style="padding: 20px; border: 2px solid black; border-radius: 20px; text-align: center;">
          <strong>③ 연결 종료</strong>
      </div>
  </div>

  - MSS(Maximum Segment Size) 단위
    * MSSS - TCP로 전송할 수 있는 최대 페이로드 크기
    * TCP 헤더 크기는 제외
    * IP MTU = IP 헤더 + TCP 헤더 + 페이로드

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Packet Table</title>
        <style>
            table {
                width: 100%;
                border-collapse: collapse;
                text-align: center;
                font-family: Arial, sans-serif;
            }
            th, td {
                border: 2px solid black;
                padding: 10px;
            }
        </style>
    </head>
    <body>

    <table>
        <tr>
            <td>이더넷 헤더</td>
            <td>IP 헤더</td>
            <td>TCP 헤더</td>
            <td>페이로드</td>
            <td>FCS</td>
        </tr>
    </table>

### TCP 세그먼트 구조

  <img src="assets/chapter4-4.png" width="800" />

  * 송신지 포트(Source Port)와 수신지(Destination Port)
    - 송수신하는 포트 번호
    - 포트 번호는 16비트로 표현할 수 있기 때문에,2^16-1까지 표현 가능

  * 순서 번호(Sequence Number) -> 중요
    - 순서 번확 명시되는 필드
    - 순서 번호
      * 송수신되는 세그먼트 데이터의 첫 바이트에 부여되는 번호
      * 세그먼트의 올바른 송수신 순서를 보장하기 위한 번호

  * 확인 응답 번호(Acknowledgment Number) -> 중요
    - 상대 호스트가 보낸 세그먼트에 대한 응답
    - 다음으로 수신하기를 기대하는 순서 번호가 명시
 
  <img src="assets/chapter4-5.png" width="800" />
  * 응용 계층으로부터 전송해야하는 1900바이트 크기의 데이터를 전달 받았다고 가정
  * 편의상 MSS 500바이트라고 가정, 4개의 세그먼트로 분할

  * 순서 번호 = 초기 순서 번호 + 송신한 바이트 수
    - 초기 순서 번호(ISN, Initail Sequence Number)는 무작위 값 -> 예시로는 100이 할당되었다 가정.
    - 세그먼트 B의 순서 번호는 초기 순서 번호인 100에서 500바이트 떨어진 셈으로 600
    - 세그먼트 C의 순서 번호는 초기 순서 번호로부터 1000바이트 떨어진 1100
    - 세그먼트 D의 순서는 초기 순서번호로부터 1500바이트 떨어진 1600

  * 확인 응답 번호
    - 수신자가 다음으로 받기를 기대하는 순서 번호(일반적으로 '수신한 순서 번호 +1')
    - 확인 응답 번호 값을 보내기 위해서는 제어 비트에서 승인을 나타내는 비트인 ACK 플래그를 1로 설정

  * 제어 비트(Control Bits) 또는 플래그 비트(Flag Bits)
    - 햔재 세그먼트에 대한 부가 정보
    - 기분적으로 8비트로 구성
      * ACK: 세그먼트의 승인을 나타내기 위한 비트
      * SYN: 연결을 수립하기 위한 비트
      * FIN: 연결을 종료하기 위한 비트

  * 윈도우(Window)
    - 수신 윈도우(한 번에 수신하고자 하는 데이터의 양)의 크기가 명시

### TCP 연결 수립과 종료 

  - 연결 수립: 쓰리 웨이 핸드셰이크
    * 쓰레 웨이 핸드셰이크(Three-way Handshake) 세 개의 단계로 이루어진 TCP의 연결 수립 과정
    * ex) 호스트 A와 B가 쓰레 웨이 핸드셰이크를 한다고 가정

  <img src="assets/chapter4-6.png" width="800" />

    * 액티브 오픈(Active Open): 연결 시작 호스트의 연결 수립과정(여기선 A)
    * 패시브 오픈(Passive Open): 연결 수락 호스트의 연결 수립 과정(여기선 B)


  - 연결 종료
    * 송수신 호스트가 각자 한 번씩 FIN과 ACK를 주고 받으며 TCP가 연결 종료
      - 액티브 클로즈(Active Close): 종료 시작 호스트의 종료 과정
      - 패시브 클로즈(Passive Close): 종료 수락 호스트의 종료 과정

  <img src="assets/chapter4-7.png" width="800" />
  
  | 송수신 방향 | 세그먼트       | 세그먼트에 포함된 주요 정보                                     | 비유              |
|:-------------:|:----------------:|:-------------------------------------------------------------|-------------------:|
| A → B       | FIN 세그먼트   | • 1로 설정된 FIN 비트                                         | ‘연결 끊을게요.’   |
| B → A       | ACK 세그먼트   | • 호스트 A가 전송한 세그먼트에 대한 확인 응답 번호<br>• 1로 설정된 ACK 비트 | ‘네, 확인했습니다.’ |
| B → A       | FIN 세그먼트   | • 1로 설정된 FIN 비트                                         | ‘이제 연결 끊어요.’ |
| A → B       | ACK 세그먼트   | • 호스트 B가 전송한 세그먼트에 대한 확인 응답 번호<br>• 1로 설정된 ACK 비트 | ‘네, 확인했습니다.’ |

- 네 단계로 연결을 종료한다는 점에서 포 웨이 핸드셰이크(Four-way Handshake)라고 부르기도 함

### TCP 상태

- 상태(State): 현재 어떤 통신 과정에 있는지를 나타내는 정보
- 상태를 유지하고 활용하는 TCP
  * 스테이트풀(Stateful) 프로토콜

- TCP 상태의 유형
  * 1. 연결이 수립되지 않은 상태
  * 2. 연결 수립과정에서 주로 볼 수 있는 상태
  * 3. 연결 종료 과정에서 주로 볼 수 있는 상태

  | 상태 분류 | 주요 상태                                                  |
  |:-----------:|:----------------------------------------------------------:|
  | ①         | CLOSED, LISTEN                                           |
  | ②         | SYN-SENT, SYN-RECEIVED, ESTABLISHED                      |
  | ③         | FIN-WAIT-1, CLOSE-WAIT, FIN-WAIT-2, LAST-ACK, TIME-WAIT, CLOSING |


- 연결이 수립되지 않은 상태
  * CLOSED - 아무런 연결이 없는 상태
  * LISTEN - 일종의 대기 상태(SYN 세그먼트를 기다리는 상태)
    - 서버로써 동작하는 패시브 오픈 호스트는 일반적으로 LISTEN 상태 유지
    - LISTEN 호스트에게 SYN 세그먼트를 보내면 쓰리 웨이 핸드셰이크 시작

- 연결 수립과정에서 주로 볼 수 있는 상태
  * SYN-SENT
    - 연결 요청을 보낸 뒤 대기하는 상태
    - 액티브 오픈 호스트가 SYN 세그먼트를 보낸 뒤 그에 대한 응답인 SYN + ACK 세그먼트를 기다리는 상태
  
  * SYN-RECEIVED
    - 패시브 오픈 호스트가 SYN + ACK 세그먼트를 보낸 뒤 그에 대한 ACK 세그먼트를 기다리는 상태
  
  * ESTABLISHED
    -  연결이 확립되었음을 나타내는 상태

- 연결 종료 상태
  * FIN-WAIT-1
    - 일반적인 TCP 연결 종료 과정에 있어 FIN-WAIT-1은 연결 종료의 첫 단계
  * CLOSE-WAIT
    - 종료 요청인 FIN 세그먼트를 받은 패시브 클로즈 호스트가 그에 대한 응답으로 ACK 세그먼트를 보낸 후 대기하는 상태
  * FIN-WAIT-2
    - FIN-WAIT-1 상태에서 ACK 세그먼트를 받고 상대 호스트의 FIN 세그먼트를 기다리는 상태
  * LAST-ACK
    - CLOSE-WAIT 상태에서 FIN 세그먼트를 전송한 뒤 이에 대한 ACK 세그먼트를 기다리는 상태
  * TIME-WAIT
    - 액티브 클로즈 호스트가 FIN 세그먼트를 수신한 뒤, 이에 대한 ACK 세그먼트를 전송한 뒤 접어드는 상태
    - 패시브 클로즈 호스트는 마지막 ACK 세그먼트를 수신하면 CLOSED 상태로 전이
    - TIME-WAIT 상태의 액티브 클로즈 호스트는 일정 시간을 기다린 뒤 CLOSED 상태로 전이
      -> ACK 세그먼트가 전송되는 과정에서 유실되거나 잘못 전송되는 경우도 있기 때문.

### UDP

  - UDP 데이터그램의 구조
    * UDP는 TCP와 달리 비연결형 통신을 수행하는 신뢰할 수 없는 프로토콜
    * 그래서 연결 수립 및 해제, 재전송을 통한 오류 제어, 혼잡 제어, 흐름 제어등을 수행하지 않음
    * 상태를 유지하지도 않음 - 스테이트리스(Stateless) 프로토콜
    * UDP는 TCP에 비해 적은 오버헤드로 패킷을 빠르게 처리
    * 주로 실시간 스트리밍 서비스, 인터넷 전화처럼 실시간성이 강조되는 상황에서 TCP보다 더 많이 쓰임

  - UDP vs TCP
    * TCP의 전송 방식은 수신지에 하나씩 확실하게 전달
    * UDP의 수신지에 패킷들을 빠르게 마구 던지는 것과 같다. 그 과정에서 패킷이 손실되거나 순서가 바뀔 수도 있다.

  <img src="assets/chapter4-8.png" width="800" />

